import {Navigator, URLOptions, NavigationOptions} from '@layr/navigator';
import {hasOwnProperty} from 'core-helpers';

import type {RoutableComponent} from './routable';
import type {Route, RouteOptions} from './route';
import type {WrapperOptions} from './wrapper';
import type {Pattern} from './pattern';
import {isRoutableClassOrInstance} from './utilities';

/**
 * Defines a [route](https://layrjs.com/docs/v1/reference/route) for a static or instance method in a [routable component](https://layrjs.com/docs/v1/reference/routable#routable-component-class).
 *
 * @param pattern The canonical [URL pattern](https://layrjs.com/docs/v1/reference/route#url-pattern-type) of the route.
 * @param [options] An object specifying the options to pass to the `Route`'s [constructor](https://layrjs.com/docs/v1/reference/route#constructor) when the route is created.
 *
 * @details
 * **Shortcut functions:**
 *
 * In addition to defining a route, the decorator adds some shortcut functions to the decorated method so that you can interact with the route more easily.
 *
 * For example, if you define a `route` for a `Home()` method you automatically get the following functions:
 *
 * - `Home.matchURL(url)` is the equivalent of [`route.matchURL(url)`](https://layrjs.com/docs/v1/reference/route#match-url-instance-method).
 * - `Home.generateURL(params, options)` is the equivalent of [`route.generateURL(params, options)`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method).
 *
 * If the defined `route` is controlled by a [`navigator`](https://layrjs.com/docs/v1/reference/navigator), you also get the following shortcut functions:
 *
 * - `Home.navigate(params, options)` is the equivalent of [`navigator.navigate(url, options)`](https://layrjs.com/docs/v1/reference/navigator#navigate-instance-method) where `url` is generated by calling [`route.generateURL(params, options)`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method).
 * - `Home.redirect(params, options)` is the equivalent of [`navigator.redirect(url, options)`](https://layrjs.com/docs/v1/reference/navigator#redirect-instance-method) where `url` is generated by calling [`route.generateURL(params, options)`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method).
 * - `Home.reload(params, options)` is the equivalent of [`navigator.reload(url)`](https://layrjs.com/docs/v1/reference/navigator#reload-instance-method) where `url` is generated by calling [`route.generateURL(params, options)`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method).
 * - `Home.isActive(params)` returns a boolean indicating whether the `route`'s URL (generated by calling [`route.generateURL(params)`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method)) matches the current `navigator`'s URL.
 *
 * Lastly, if the defined `route` is controlled by a [`navigator`](https://layrjs.com/docs/v1/reference/navigator) that is created by using the [`useBrowserNavigator()`](https://layrjs.com/docs/v1/reference/react-integration#use-browser-navigator-react-hook) React hook, you also get the following shortcut function:
 *
 * - `Home.Link({params, hash, ...props})` is the equivalent of [`navigator.Link({to, ...props})`](https://layrjs.com/docs/v1/reference/browser-navigator#link-instance-method) where `to` is generated by calling [`route.generateURL(params, {hash})`](https://layrjs.com/docs/v1/reference/route#generate-url-instance-method).
 *
 * @examplelink See an example of use in the [`BrowserNavigator`](https://layrjs.com/docs/v1/reference/browser-navigator) class.
 *
 * @category Decorators
 * @decorator
 */
export function route(pattern: Pattern, options: RouteOptions = {}) {
  return function (
    target: typeof RoutableComponent | RoutableComponent,
    name: string,
    descriptor: PropertyDescriptor
  ) {
    const {value: method, get: originalGet, configurable, enumerable} = descriptor;

    if (
      !(
        isRoutableClassOrInstance(target) &&
        (typeof method === 'function' || originalGet !== undefined) &&
        enumerable === false
      )
    ) {
      throw new Error(
        `@route() should be used to decorate a routable component method (property: '${name}')`
      );
    }

    const route: Route = target.setRoute(name, pattern, options);

    const decorate = function (
      this: typeof RoutableComponent | RoutableComponent,
      method: Function
    ) {
      const component = this;

      defineMethod(method, 'matchURL', function (url: URL | string) {
        return route.matchURL(url);
      });

      defineMethod(method, 'generateURL', function (params?: any, options?: URLOptions) {
        return route.generateURL(component, params, options);
      });

      defineMethod(method, 'generatePath', function () {
        return route.generatePath(component);
      });

      defineMethod(method, 'generateQueryString', function (params?: any) {
        return route.generateQueryString(params);
      });

      Object.defineProperty(method, '__isDecorated', {value: true});
    };

    const decorateWithNavigator = function (
      this: typeof RoutableComponent | RoutableComponent,
      method: Function,
      navigator: Navigator
    ) {
      defineMethod(
        method,
        'navigate',
        function (this: Function, params?: any, options?: URLOptions & NavigationOptions) {
          return navigator.navigate(this.generateURL(params, options), options);
        }
      );

      defineMethod(
        method,
        'redirect',
        function (this: Function, params?: any, options?: URLOptions & NavigationOptions) {
          return navigator.redirect(this.generateURL(params, options), options);
        }
      );

      defineMethod(method, 'reload', function (this: Function, params?: any, options?: URLOptions) {
        navigator.reload(this.generateURL(params, options));
      });

      defineMethod(method, 'isActive', function (this: Function) {
        const currentPath = navigator.getCurrentPath();
        const routePath = this.generatePath();

        return routePath === currentPath;
      });

      navigator.applyCustomRouteDecorators(this, method);

      Object.defineProperty(method, '__isDecoratedWithNavigator', {value: true});
    };

    const defineMethod = function (object: any, name: string, func: Function) {
      Object.defineProperty(object, name, {
        value: func,
        writable: true,
        enumerable: false,
        configurable: true
      });
    };

    const get = function (this: typeof RoutableComponent | RoutableComponent) {
      // TODO: Don't assume that `originalGet` returns a bound method (like when @view() is used).
      // We should return a bound method in any case to make instance routes work
      // (see `decorator.test.ts`)

      const actualMethod = originalGet !== undefined ? originalGet.call(this) : method;

      if (typeof actualMethod !== 'function') {
        throw new Error(`@route() can only be used on methods`);
      }

      if (!hasOwnProperty(actualMethod, '__isDecorated')) {
        decorate.call(this, actualMethod);
      }

      if (!hasOwnProperty(actualMethod, '__isDecoratedWithNavigator')) {
        const navigator = this.findNavigator();

        if (navigator !== undefined) {
          decorateWithNavigator.call(this, actualMethod, navigator);
        }
      }

      return actualMethod;
    };

    return {get, configurable, enumerable};
  };
}

export function wrapper(pattern: Pattern, options: WrapperOptions = {}) {
  return function (
    target: typeof RoutableComponent | RoutableComponent,
    name: string,
    descriptor: PropertyDescriptor
  ) {
    const {value: method, get, enumerable} = descriptor;

    if (
      !(
        isRoutableClassOrInstance(target) &&
        (typeof method === 'function' || get !== undefined) &&
        enumerable === false
      )
    ) {
      throw new Error(
        `@wrapper() should be used to decorate a routable component method (property: '${name}')`
      );
    }

    target.setWrapper(name, pattern, options);

    return descriptor;
  };
}

const HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'] as const;
const ANY_HTTP_METHOD = '*';

type HTTPMethod = typeof HTTP_METHODS[number];
type AnyHTTPMethod = typeof ANY_HTTP_METHOD;

export function basicHTTPRouteInputTransformer(params: any, _request: any) {
  return params;
}

export function basicHTTPRouteOutputTransformer(result: any, request: any) {
  let response: {status?: number; headers?: Record<string, string>; body?: string | Buffer} = {};

  if (result === undefined) {
    response.status = 204; // No Content
  } else {
    if (request?.method === 'POST') {
      response.status = 201; // Created
    } else {
      response.status = 200; // OK
    }

    if (Buffer.isBuffer(result)) {
      response.headers = {'content-type': 'application/octet-stream'};
      response.body = result;
    } else {
      response.headers = {'content-type': 'application/json'};
      response.body = JSON.stringify(result);
    }
  }

  return response;
}

export function basicHTTPRouteErrorTransformer(error: any, _request: any) {
  const response: {status: number; headers: Record<string, string>; body: string} = {
    status: 500,
    headers: {'content-type': 'application/json'},
    body: JSON.stringify({
      message: 'Internal server error'
    })
  };

  if (typeof error !== 'object' || error === null) {
    return response;
  }

  if (typeof error.status === 'number') {
    response.status = error.status;
  }

  const expose: boolean = typeof error.expose === 'boolean' ? error.expose : response.status < 500;

  if (expose) {
    const body: Record<string, any> = {};

    body.message = typeof error.message === 'string' ? error.message : 'Unknown error';

    for (const [key, value] of Object.entries(error)) {
      if (key === 'status' || key === 'message' || value === undefined) {
        continue;
      }

      body[key] = value;
    }

    response.body = JSON.stringify(body);
  }

  return response;
}

export function httpRoute(
  httpMethod: HTTPMethod | AnyHTTPMethod,
  pattern: Pattern,
  options: RouteOptions = {}
) {
  if (!(httpMethod === ANY_HTTP_METHOD || HTTP_METHODS.includes(httpMethod))) {
    throw new Error(
      `The HTTP method '${httpMethod}' is not supported by the @httpRoute() decorator (supported values are: ${HTTP_METHODS.map(
        (method) => `'${method}'`
      ).join(', ')}, or '${ANY_HTTP_METHOD}')`
    );
  }

  const {
    filter = function (request) {
      return httpMethod === '*'
        ? HTTP_METHODS.includes(request?.method)
        : request?.method === httpMethod;
    },
    transformers = {},
    ...otherOptions
  } = options;

  const {
    input = basicHTTPRouteInputTransformer,
    output = basicHTTPRouteOutputTransformer,
    error = basicHTTPRouteErrorTransformer
  } = transformers;

  return function (
    target: typeof RoutableComponent | RoutableComponent,
    name: string,
    descriptor: PropertyDescriptor
  ) {
    return route(pattern, {filter, transformers: {input, output, error}, ...otherOptions})(
      target,
      name,
      descriptor
    );
  };
}
